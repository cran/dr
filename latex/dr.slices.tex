\Header{dr.slices}{Divide a vector into slices of approximately equal size}
\alias{dr.slice.1d}{dr.slices}
\alias{dr.slice1}{dr.slices}
\alias{dr.slice2}{dr.slices}
\keyword{~kwd1}{dr.slices}
\keyword{~kwd2}{dr.slices}
\begin{Description}\relax
Divides a vector into slices of approximately equal size.\end{Description}
\begin{Usage}
\begin{verbatim}
dr.slices(y, nslices)
\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] a vector of length n or an n by p matrix
\item[\code{nslices}] the number of slices, no larger than n, or a vector of
p numbers giving the number of slices in each direction.  If y has p 
columns and nslices is a number, then the number of slices in each direction
is the smallest integer greater than nslices$^(1/p)$.
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
If y is an n-vector, order y.  The goal for the number of observations per slice
is m, the smallest integer in nslices/n. Allocate the first m observations to
slice 1.  If there are duplicates in y, keep adding observations to the first
slice until the next value of y is not equal to the largest value in the 
first slice.  Allocate the next m values to the next slice, and again check 
for ties.  Continue until all values are allocated to a slice.  This does not
guarantee that nslices will be obtained, nor does it guarantee an equal number
of observations per slice.  This method of choosing slices is invariant under
rescaling, but not under multiplication by -1, so the slices of y will not
be the same as the slices of -y.

If y is a matrix of p columns, slice the first column as described above.  Then,
within each of the slices determined for the first column, slice based on the
second column, so that each of the "cells" has approximately the same number
of observations.  Continue through all the columns.  This method is not
invariant under reordering of the columns, or under multiplication by -1.\end{Details}
\begin{Value}
Returns an object with three attributes.  
 \item[slice.sizes] gives the number
of observations per slice.  
 \item[slice.indicator] is an n-vector giving the
slice number of each observatin.  
	\item[nlices] gives the actual number of slices produced
\end{Value}
\begin{Author}\relax
Sanford Weisberg, <sandy@stat.umn.edu>\end{Author}
\begin{References}\relax
This function produces the same slice indicators as does the
equivalent function in Arc, Cook and Weisberg (1999), Applied Regression Including
Computing and Graphics, New York:  Wiley.\end{References}
\begin{SeeAlso}\relax
\code{\Link{dr}}\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--         or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(y,nslices) {
  p <- if (is.matrix(y)) dim(y)[2] else 1
  h <- if (length(nslices) == p) nslices else rep(ceiling(nslices^(1/p)),p)
  a <- dr.slice.1d( if(is.matrix(y)) y[,1] else y, h[1])
  if (p > 1){
    for (col in 2:p) {
       ns <- 0
       for (j in unique(a$slice.indicator)) {
         b <- dr.slice.1d(y[a$slice.indicator==j,col],h[col])
     a$slice.indicator[a$slice.indicator==j] <- 
          a$slice.indicator[a$slice.indicator==j] +
          10^(p-1)*b$slice.indicator
     ns <- ns + b$nslices}
       a$nslices <- ns }
#recode unique values to 1:nslices and fix up slice sizes
    v <- unique(a$slice.indicator)
    L <- NULL
    for (i in 1:length(v)) {
       sel <- a$slice.indicator==v[i]
       a$slice.indicator[sel] <- i
       L <- c(L,length(a$slice.indicator[sel]))}
    a$slice.sizes <- L }
  a}
\end{ExampleCode}
\end{Examples}

